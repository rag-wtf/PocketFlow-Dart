import 'package:pocketflow/pocketflow.dart';
import 'package:test/test.dart';

// These test nodes are designed to work with the current Flow implementation,
// where state is passed through the `shared` map.

class NumberNode extends Node {
  NumberNode(int initial) {
    params['value'] = initial;
  }

  @override
  Future<int> exec(dynamic prepResult) async {
    return params['value'] as int;
  }

  @override
  Future<dynamic> post(
      Map<String, dynamic> shared, dynamic prepResult, dynamic execResult) {
    shared['value'] = execResult;
    return Future.value(execResult);
  }
}

class AddNode extends Node {
  AddNode(int value) {
    params['value'] = value;
  }

  @override
  Future<int> prep(Map<String, dynamic> shared) async {
    return (shared['value'] ?? 0) as int;
  }

  @override
  Future<int> exec(dynamic prepResult) async {
    return prepResult + (params['value'] as int);
  }

  @override
  Future<dynamic> post(
      Map<String, dynamic> shared, dynamic prepResult, dynamic execResult) {
    shared['value'] = execResult;
    return Future.value(execResult);
  }
}

class MultiplyNode extends Node {
  MultiplyNode(int value) {
    params['value'] = value;
  }

  @override
  Future<int> prep(Map<String, dynamic> shared) async {
    return (shared['value'] ?? 0) as int;
  }

  @override
  Future<int> exec(dynamic prepResult) async {
    return prepResult * (params['value'] as int);
  }

  @override
  Future<dynamic> post(
      Map<String, dynamic> shared, dynamic prepResult, dynamic execResult) {
    shared['value'] = execResult;
    return Future.value(execResult);
  }
}

class BranchNode extends Node {
  BranchNode(int value) {
    params['value'] = value;
  }

  @override
  Future<int> prep(Map<String, dynamic> shared) async {
    return (shared['value'] ?? 0) as int;
  }

  @override
  Future<String> exec(dynamic prepResult) async {
    return prepResult > params['value'] ? 'positive' : 'negative';
  }

  @override
  Future<dynamic> post(
      Map<String, dynamic> shared, dynamic prepResult, dynamic execResult) {
    return Future.value(execResult);
  }
}

class CycleNode extends Node {
  @override
  Future<int> prep(Map<String, dynamic> shared) async {
    return shared['value'] as int;
  }

  @override
  Future<int> exec(dynamic prepResult) async {
    return prepResult - 1;
  }

  @override
  Future<dynamic> post(
    Map<String, dynamic> shared,
    dynamic prepResult,
    dynamic execResult,
  ) async {
    shared['value'] = execResult;
    if (execResult <= 0) {
      return 'end';
    }
    return 'default';
  }
}

void main() {
  group('Flow', () {
    test('run() without a start node should throw a StateError', () async {
      final flow = Flow();
      expect(() => flow.run({}), throwsStateError);
    });

    test('start().run() should execute a single node', () async {
      final flow = Flow();
      flow.start(NumberNode(10));
      final shared = <String, dynamic>{};
      final result = await flow.run(shared);
      expect(result, 10);
      expect(shared['value'], 10);
    });

    test('start().next().next() should execute a chain of nodes', () async {
      final flow = Flow();
      flow.start(NumberNode(10)).next(AddNode(5)).next(MultiplyNode(2));
      final shared = <String, dynamic>{};
      final result = await flow.run(shared);
      expect(result, 30);
      expect(shared['value'], 30);
    });

    test('next() should execute a sequence of nodes', () async {
      final flow = Flow();
      final startNode = NumberNode(10);
      final addNode = AddNode(5);
      final multiplyNode = MultiplyNode(2);

      flow.start(startNode);
      startNode.next(addNode);
      addNode.next(multiplyNode);

      final result = await flow.run({});
      expect(result, 30);
    });

    test('should follow the "positive" branch', () async {
      final flow = Flow();
      final startNode = NumberNode(15);
      final branchNode = BranchNode(10);
      final positiveNode = NumberNode(100);
      final negativeNode = NumberNode(200);

      flow.start(startNode);
      startNode.next(branchNode);
      branchNode.next(positiveNode, action: 'positive');
      branchNode.next(negativeNode, action: 'negative');

      final result = await flow.run({});
      expect(result, 100);
    });

    test('should follow the "negative" branch', () async {
      final flow = Flow();
      final startNode = NumberNode(5);
      final branchNode = BranchNode(10);
      final positiveNode = NumberNode(100);
      final negativeNode = NumberNode(200);

      flow.start(startNode);
      startNode.next(branchNode);
      branchNode.next(positiveNode, action: 'positive');
      branchNode.next(negativeNode, action: 'negative');

      final result = await flow.run({});
      expect(result, 200);
    });

    test('should cycle until a condition is met and return a signal',
        () async {
      final flow = Flow();
      final startNode = NumberNode(5);
      final cycleNode = CycleNode();
      final endNode = NumberNode(999);

      flow.start(startNode);
      startNode.next(cycleNode);
      cycleNode.next(cycleNode, action: 'default');
      cycleNode.next(endNode, action: 'end');

      final result = await flow.run({});
      expect(result, 999);
    });

    test('should not persist state between runs', () async {
      final flow = Flow();
      flow.start(NumberNode(10)).next(AddNode(5));

      final result1 = await flow.run({});
      expect(result1, 15);

      // The shared state is NOT reset between runs, but the flow execution is.
      // So the second run starts with shared['value'] = 15 from the previous run.
      final result2 = await flow.run({});
      expect(result2, 15);
    });

    test('should pass parameters to nodes by name', () async {
      final flow = Flow();
      final startNode = NumberNode(0)..name = 'start';
      final addNode = AddNode(0)..name = 'add';
      flow.start(startNode).next(addNode);

      final shared = {
        '__node_params__': {
          'start': {'value': 10},
          'add': {'value': 5},
        }
      };

      final result = await flow.run(shared);
      expect(result, 15);
    });

    test('Flow.clone() should create a deep copy of the graph', () async {
      final flow = Flow();
      final startNode = NumberNode(10);
      final addNode = AddNode(5);
      startNode.next(addNode);
      flow.start(startNode);

      final clonedFlow = flow.clone();

      // Ensure the flows are different instances
      expect(clonedFlow, isNot(same(flow)));

      // Run both flows and check results
      final originalResult = await flow.run({});
      final clonedResult = await clonedFlow.run({});
      expect(originalResult, 15);
      expect(clonedResult, 15);

      // Modify the original flow and check if the clone is affected
      addNode.params['value'] = 10;
      final newOriginalResult = await flow.run({});
      final newClonedResult = await clonedFlow.run({});
      expect(newOriginalResult, 20);
      expect(newClonedResult, 15);
    });

    test('clone should create a copy of a flow with params', () {
      final flow = Flow();
      flow.params['param1'] = 'value1';
      final clonedFlow = flow.clone();
      expect(clonedFlow.params['param1'], 'value1');
      expect(clonedFlow, isNot(same(flow)));
    });
  });
}